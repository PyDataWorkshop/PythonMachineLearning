\documentclass[MASTER.tex]{subfiles} 
\begin{document} 

%===========================================================%
\begin{frame}[fragile]
	\frametitle{Special Arrays}
	Functions are available to construct a number of useful, frequently encountered arrays.
\end{frame}
%===========================================================%
\begin{frame}[fragile]
	%-------------------------%
	\frametitle{\texttt{ones}}
	ones generates an array of 1s and is generally called with one argument, a tuple, containing the size of
	each dimension. \texttt{ones} takes an optional second argument (\texttt{dtype}) to specify the data type. If omitted, the
	data type is \texttt{float}.
	\begin{framed}
		\begin{verbatim}
		>>> M, N = 5, 5
		>>> x = ones((M,N)) # M by N array of 1s
		>>> x = ones((M,M,N)) # 3D array
		>>> x = ones((M,N), dtype=’int32’) # 32bit integers
		\end{verbatim}
	\end{framed}
\end{frame}

%===========================================================%
\begin{frame}[fragile]
	\frametitle{zeros}
	zeros produces an array of 0s in the same way ones produces an array of 1s, and commonly used to initialize
	an array to hold values generated by another procedure. zeros takes an optional second argument
	(dtype) to specify the data type. If omitted, the data type is float.
	\begin{framed}
		\begin{verbatim}
		>>> x = zeros((M,N)) # M by N array of 0s
		>>> x = zeros((M,M,N)) # 3D array of 0s
		>>> x = zeros((M,N),dtype=’int64’) # 64 bit integers
		\end{verbatim}
	\end{framed}

	
\end{frame}
%===========================================================%
\begin{frame}[fragile]
	%-------------------------%
	\frametitle{\texttt{ones}}
	\texttt{ones\_like} creates an array with the same shape and data type as the input. Calling \texttt{ones\_like(x)} is equivalent
	to calling \texttt{ones(x.shape,x.dtype)}.
	zeros\_like creates an array with the same size and shape as the input. Calling zeros\_like(x) is equivalent
	to calling zeros(x.shape,x.dtype).
\end{frame}
%===========================================================%
\begin{frame}[fragile]
	\frametitle{\texttt{empty}}
	empty produces an empty (uninitialized) array to hold values generated by another procedure. empty takes
	an optional second argument (\texttt{dtype}) which specifies the data type. If omitted, the data type is float.
	\begin{framed}
		\begin{verbatim}
		>>> x = empty((M,N)) # M by N empty array
		>>> x = empty((N,N,N,N)) # 4D empty array
		>>> x = empty((M,N),dtype=’float32’) # 32bit
		\end{verbatim}
	\end{framed}
\end{frame}
%===========================================================%
\begin{frame}[fragile]
	\frametitle{floats (single precision)}
	\begin{itemize}
	\item Using empty is slightly faster than calling zeros since it does not assign 0 to all elements of the array –
	the “empty” array created will be populated with (essential random) non-zero values. 
	\item empty\_like creates
	an array with the same size and shape as the input. 
	\item Calling empty\_like(x) is equivalent to calling
	empty(x.shape,x.dtype).
	\end{itemize}
\end{frame}
%===========================================================%
\begin{frame}[fragile]
	\frametitle{eye, identity}
	\texttt{eye} generates an identity array – an array with ones on the diagonal, zeros everywhere else. Normally,
	an identity array is square and so usually only 1 input is required. More complex zero-padded arrays
	containing an identity matrix can be produced using optional inputs.
	\begin{framed}
		\begin{verbatim}
		>>> In = eye(N)
		\end{verbatim}
	\end{framed}
	identity is a virtually identical function with similar use, In = identity(N).
\end{frame}
%===========================================================%
\end{document}